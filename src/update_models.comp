#version 450

#include "shared.h"

layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std140, set = 0, binding = 0) readonly restrict buffer orbit_spec_data {
	orbit_spec spec;
};

layout(std140, set = 0, binding = 1) writeonly restrict buffer orbit_tfm {
	mat4 model[MAX_ITEMS];
} result;

/*
struct draw_indirect_data {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};

layout(std340, set = 1, binding = 2) writeonly restrict buffer draw_commands {
	draw_indirect_data draw;
};
*/

layout(push_constant) uniform info {
	push_constant_data draw;
};

vec3 rotate_axis_angle(vec3 v, float amount, vec3 axis)
{
	float s = sin(amount);
	float c = cos(amount);
	return c * v + s * cross(axis, v) + (1.0 - c) * dot(axis, v) * axis;
}

vec3 flatten(uint node)
{
	vec3 pos = vec3(0.0);
	uint cur_index = node;
	for (uint iter = 0; iter < draw.tree_height; iter++) {
		pos += rotate_axis_angle(
			spec.startoffset[cur_index].xyz,
			spec.orbitspeed[cur_index] * draw.time,
			spec.orbitaxis[cur_index].xyz);
		cur_index = spec.parent[cur_index];
	}
	return pos;
}

void main()
{
	uint node = gl_GlobalInvocationID.x;
	vec3 pos = flatten(node);
	// float scale = spec.itemscale[node];
	float scale = 1.0;
	mat4 model;
	model[0] = vec4(scale, 0.0, 0.0, 0.0);
	model[1] = vec4(0.0, scale, 0.0, 0.0);
	model[2] = vec4(0.0, 0.0, scale, 0.0);
	model[3] = vec4(pos.xyz,         1.0);
	result.model[draw.baseindex + node] = model;
}

