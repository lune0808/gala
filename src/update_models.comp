#version 450

#include "shared.h"


layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) restrict buffer orbit_spec_data {
	orbit_spec spec;
};

layout(std430, set = 0, binding = 1) writeonly restrict buffer orbit_tfm {
	mat4 model[MAX_ITEMS];
} result;

layout(std430, set = 0, binding = 2) writeonly restrict buffer lods {
	uint partial[MAX_ITEMS];
};

layout(r8ui, set = 0, binding = 4) uniform restrict uimage2DArray lastlod;

layout(push_constant) uniform info_t {
	push_constant_data info;
};

vec3 rotate_axis_angle(vec3 v, float amount, vec3 axis)
{
	float s = sin(amount);
	float c = cos(amount);
	return c * v + s * cross(axis, v) + (1.0 - c) * dot(axis, v) * axis;
}

mat3 quat2mat3(vec4 q)
{
	return mat3(
		vec3(2.0 * (q.w*q.w + q.x*q.x) - 1.0, 2.0 * (q.x*q.y + q.w*q.z)      , 2.0 * (q.x*q.z - q.w*q.y)      ),
		vec3(2.0 * (q.x*q.y - q.w*q.z)      , 2.0 * (q.w*q.w + q.y*q.y) - 1.0, 2.0 * (q.y*q.z + q.w*q.x)      ),
		vec3(2.0 * (q.x*q.z + q.w*q.y)      , 2.0 * (q.y*q.z - q.w*q.x)      , 2.0 * (q.w*q.w + q.z*q.z) - 1.0)
	);
}

mat4 quat2mat4(vec4 q)
{
	mat3 rot = quat2mat3(q);
	return mat4(
		vec4(rot[0]   , 0.0),
		vec4(rot[1]   , 0.0),
		vec4(rot[2]   , 0.0),
		vec4(vec3(0.0), 1.0)
	);
}

vec4 quat_mul(vec4 a, vec4 b)
{
	vec3 va = a.xyz;
	vec3 vb = b.xyz;
	return vec4(a.w*vb + b.w*va + cross(va, vb), a.w*b.w - dot(va, vb));
}

vec4 quat_integrate(vec4 q, vec3 omega, float dt)
{
	vec4 dq = vec4(dt * omega, 1.0);
	return normalize(quat_mul(q, dq));
}

vec3 flatten(uint node)
{
	vec3 pos = vec3(0.0);
	uint icur = node;
	for (uint iter = 0; iter < info.tree_height; iter++) {
		vec4 q = spec.orbitorient[icur];
		mat3 rot = quat2mat3(q);
		pos += rot * spec.startoffset[icur].xyz;
		icur = spec.parent[icur];
	}
	return pos;
}

uint best_lod(uint inode, vec3 pos, float scale)
{
	const float tolerance[MAX_LOD - 1] = { 5e2, 2e3, 8e4 };
	vec3 to_cam = pos - info.cam_pos.xyz;
	float dist2 = dot(to_cam, to_cam);
	float score = dist2 / (scale * scale);
	for (uint lod = 0; lod < MAX_LOD - 1; lod++) {
		if (score < tolerance[lod]) {
			return lod;
		}
	}
	return MAX_LOD - 1;
}

void main()
{
	uint inode = gl_GlobalInvocationID.x;
	vec3 pos = flatten(inode);
	float scale = spec.itemscale[inode];
	vec4 q = quat_integrate(spec.selforient[inode], spec.selfderiv[inode].xyz, info.dt);
	spec.selforient[inode] = q;
	mat4 model;
	mat3 rot = quat2mat3(q);
	model[0] = vec4(scale * rot[0], 0.0);
	model[1] = vec4(scale * rot[1], 0.0);
	model[2] = vec4(scale * rot[2], 0.0);
	model[3] = vec4(pos.xyz, 1.0);
	uint best = best_lod(inode, pos, scale);
	vec4 clip = info.viewproj * vec4(pos, 1.0);
	clip.xy /= clip.w;
	float edge = 1.0 + scale / clip.w;
	if (clip.x < -edge || clip.x > +edge || clip.y < -edge || clip.y > +edge) {
		best = MAX_LOD;
	}
	model[3].w = spec.texindex[inode];
	uint imodel = info.baseindex * MAX_ITEMS_PER_FRAME + inode;
	result.model[imodel] = model;
	partial[imodel] = best;
	spec.orbitorient[inode]
		= quat_integrate(spec.orbitorient[inode], spec.orbitderiv[inode].xyz, info.dt);
	if (best == MAX_LOD - 1) {
		ivec3 idim = imageSize(lastlod);
		vec3 dim = idim;
		ivec3 coord = ivec3((clip.xy * 0.5 + 0.5) * dim.xy, info.baseindex);
		if (0 <= coord.x && coord.x < dim.x
		 && 0 <= coord.y && coord.y < dim.y) {
			imageStore(lastlod, coord, uvec4(0xff));
		}
	}
}

