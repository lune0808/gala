#version 450

#include "shared.h"

layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly restrict buffer orbit_spec_data {
	orbit_spec spec;
};

layout(std430, set = 0, binding = 1) writeonly restrict buffer orbit_tfm {
	mat4 model[MAX_ITEMS];
} result;

struct VkDrawIndexedIndirectCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};

layout(std430, set = 0, binding = 2) writeonly restrict buffer draw_commands {
	VkDrawIndexedIndirectCommand draw[MAX_DRAW];
};

layout(push_constant) uniform info_t {
	push_constant_data info;
};

vec3 rotate_axis_angle(vec3 v, float amount, vec3 axis)
{
	float s = sin(amount);
	float c = cos(amount);
	return c * v + s * cross(axis, v) + (1.0 - c) * dot(axis, v) * axis;
}

vec3 flatten(uint node)
{
	vec3 pos = vec3(0.0);
	uint icur = node;
	for (uint iter = 0; iter < info.tree_height; iter++) {
		pos += rotate_axis_angle(
			spec.startoffset[icur].xyz,
			spec.orbitspeed[icur] * info.time,
			spec.orbitaxis[icur].xyz);
		icur = spec.parent[icur];
	}
	return pos;
}

void main()
{
	uint inode = gl_GlobalInvocationID.x;
	vec3 pos = flatten(inode);
	float scale = spec.itemscale[inode];
	mat4 model;
	model[0] = vec4(scale, 0.0, 0.0, 0.0);
	model[1] = vec4(0.0, scale, 0.0, 0.0);
	model[2] = vec4(0.0, 0.0, scale, 0.0);
	model[3] = vec4(pos.xyz,         1.0);
	model[3].w = spec.texindex[inode];
	uint imodel = info.baseindex * MAX_ITEMS_PER_FRAME + inode;
	result.model[imodel] = model;
	uint ilod = 3;
	uint idraw = info.baseindex * MAX_LOD + ilod;
	atomicAdd(draw[idraw].instanceCount, 1);
	if (inode < MAX_LOD) {
		uint next_draw_index =
			((info.baseindex + 1) % MAX_FRAMES_RENDERING) * MAX_LOD
			+ ilod;
		draw[next_draw_index].instanceCount = 0;
	}
}

