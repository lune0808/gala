#version 450

#include "shared.h"

layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) restrict buffer orbit_spec_data {
	orbit_spec spec;
};

layout(std430, set = 0, binding = 1) writeonly restrict buffer orbit_tfm {
	mat4 model[MAX_ITEMS];
} result;

struct VkDrawIndexedIndirectCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};

layout(std430, set = 0, binding = 2) writeonly restrict buffer draw_commands {
	VkDrawIndexedIndirectCommand draw[MAX_DRAW];
};

layout(push_constant) uniform info_t {
	push_constant_data info;
};

vec3 rotate_axis_angle(vec3 v, float amount, vec3 axis)
{
	float s = sin(amount);
	float c = cos(amount);
	return c * v + s * cross(axis, v) + (1.0 - c) * dot(axis, v) * axis;
}

vec3 flatten(uint node)
{
	vec3 pos = vec3(0.0);
	uint icur = node;
	for (uint iter = 0; iter < info.tree_height; iter++) {
		pos += rotate_axis_angle(
			spec.startoffset[icur].xyz,
			spec.orbitspeed[icur] * info.time,
			spec.orbitaxis[icur].xyz);
		icur = spec.parent[icur];
	}
	return pos;
}

shared uint nlod[MAX_LOD];
shared uint ilod[MAX_LOD];

uint best_lod(uint inode, vec3 pos, float scale)
{
	const float tolerance[MAX_LOD - 1] = { 5e1, 5e3, 5e4 };
	vec3 to_cam = pos - info.cam_pos.xyz;
	float score = dot(to_cam, to_cam) / (scale * scale);
	for (uint lod = 0; lod < MAX_LOD - 1; lod++) {
		if (score < tolerance[lod]) {
			return lod;
		}
	}
	return MAX_LOD - 1;
}

mat3 quat2mat(vec4 q)
{
	return mat3(
		vec3(2.0 * (q.w*q.w + q.x*q.x) - 1.0,
		     2.0 * (q.x*q.y + q.w*q.z)      ,
		     2.0 * (q.x*q.z - q.w*q.y)      ),
		vec3(2.0 * (q.x*q.y - q.w*q.z)      ,
		     2.0 * (q.w*q.w + q.y*q.y) - 1.0,
		     2.0 * (q.y*q.z + q.w*q.x)      ),
		vec3(2.0 * (q.x*q.z + q.w*q.y)      ,
		     2.0 * (q.y*q.z - q.w*q.x)      ,
		     2.0 * (q.w*q.w + q.z*q.z) - 1.0));
}

vec4 quat_mul(vec4 a, vec4 b)
{
	vec3 va = a.xyz;
	vec3 vb = b.xyz;
	return vec4(a.w * vb + b.w * va + cross(va, vb), a.w * b.w - dot(va, vb));
}

void main()
{
	if (gl_LocalInvocationID.x == 0) {
		for (uint i = 0; i < MAX_LOD; i++) {
			nlod[i] = 0;
		}
	}
	memoryBarrierShared();

	uint inode = gl_GlobalInvocationID.x;
	uint wdraw = info.baseindex * MAX_DRAW_PER_FRAME
		   + gl_WorkGroupID.x * MAX_LOD;
	vec3 pos = flatten(inode);
	float scale = spec.itemscale[inode];
	mat4 model;
	vec4 q = spec.selforient[inode];
	vec4 dq = vec4(info.dt * spec.selfderiv[inode].xyz, 1.0);
	q = normalize(quat_mul(dq, q));
	mat3 rot = quat2mat(q);
	spec.selforient[inode] = q;
	model[0] = vec4(scale * rot[0], 0.0);
	model[1] = vec4(scale * rot[1], 0.0);
	model[2] = vec4(scale * rot[2], 0.0);
	model[3] = vec4(pos.xyz       , 1.0);
	uint best = best_lod(inode, pos, scale);
	uint idraw = wdraw + best;
	model[3].w = spec.texindex[inode];
	uint local = atomicAdd(nlod[best], 1);
	uint wmodel = info.baseindex * MAX_ITEMS_PER_FRAME
		    + gl_WorkGroupID.x * LOCAL_SIZE;

	memoryBarrierShared();
	if (gl_LocalInvocationID.x == 0) {
		uint nlod0 = nlod[0];
		uint nlod1 = nlod[1];
		uint nlod2 = nlod[2];
		uint nlod3 = nlod[3];
		uint ilod0 = wmodel;
		uint ilod1 = ilod0 + nlod0;
		uint ilod2 = ilod1 + nlod1;
		uint ilod3 = ilod2 + nlod2;
		ilod[0] = ilod0;
		ilod[1] = ilod1;
		ilod[2] = ilod2;
		ilod[3] = ilod3;
	}
	memoryBarrierShared();

	uint imodel = ilod[best] + local;
	result.model[imodel] = model;

	if (gl_LocalInvocationID.x == 0) {
		for (uint i = 0; i < MAX_LOD; i++) {
			draw[wdraw + i].instanceCount = nlod[i];
			draw[wdraw + i].firstInstance = ilod[i];
		}
	}
}

