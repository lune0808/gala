#version 450

#include "shared.h"

layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly restrict buffer orbit_spec_data {
	orbit_spec spec;
};

layout(std430, set = 0, binding = 1) writeonly restrict buffer orbit_tfm {
	mat4 model[MAX_ITEMS];
} result;

struct VkDrawIndexedIndirectCommand {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	int  vertexOffset;
	uint firstInstance;
};

layout(std430, set = 0, binding = 2) writeonly restrict buffer draw_commands {
	VkDrawIndexedIndirectCommand draw[MAX_DRAW];
};

layout(push_constant) uniform info_t {
	push_constant_data info;
};

vec3 rotate_axis_angle(vec3 v, float amount, vec3 axis)
{
	float s = sin(amount);
	float c = cos(amount);
	return c * v + s * cross(axis, v) + (1.0 - c) * dot(axis, v) * axis;
}

vec3 flatten(uint node)
{
	vec3 pos = vec3(0.0);
	uint cur_index = node;
	for (uint iter = 0; iter < info.tree_height; iter++) {
		pos += rotate_axis_angle(
			spec.startoffset[cur_index].xyz,
			spec.orbitspeed[cur_index] * info.time,
			spec.orbitaxis[cur_index].xyz);
		cur_index = spec.parent[cur_index];
	}
	return pos;
}

void main()
{
	uint node = gl_GlobalInvocationID.x;
	vec3 pos = flatten(node);
	float scale = spec.itemscale[node];
	mat4 model;
	model[0] = vec4(scale, 0.0, 0.0, 0.0);
	model[1] = vec4(0.0, scale, 0.0, 0.0);
	model[2] = vec4(0.0, 0.0, scale, 0.0);
	model[3] = vec4(pos.xyz,         1.0);
	model[3].w = spec.texindex[node];
	result.model[info.baseindex * MAX_ITEMS_PER_FRAME + node] = model;
}

